[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mastering Nextflow: From Fundamentals to Expert Practice",
    "section": "",
    "text": "1 Intro\nLearn how to read a comma-separated sample metadata file containing semicolon-separated FASTQ file lists, and inspect parsed outputs using channels in Nextflow DSL2.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Intro</span>"
    ]
  },
  {
    "objectID": "index.html#star-this-repository",
    "href": "index.html#star-this-repository",
    "title": "Mastering Nextflow: From Fundamentals to Expert Practice",
    "section": "1.1 Star This Repository",
    "text": "1.1 Star This Repository\nIf you find this Nextflow tutorial helpful, please consider starring the repository on GitHub! Your support helps others discover this resource and motivates continued development.\n\n\n\nGitHub stars\n\n\nStar on GitHub →\n\nChannel.fromPath(params.metatab) .splitCsv(header:true, sep:‘,’)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Intro</span>"
    ]
  },
  {
    "objectID": "02-methods.html",
    "href": "02-methods.html",
    "title": "3  Test 2",
    "section": "",
    "text": "Test 2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "03-results.html",
    "href": "03-results.html",
    "title": "4  Test 3",
    "section": "",
    "text": "Test3",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "04-advanced_metadata.html",
    "href": "04-advanced_metadata.html",
    "title": "5  Validating Input with nf-schema",
    "section": "",
    "text": "5.1 Utilizing\nThis Nextflow plugin provides functionality that can be used in a Nextflow pipeline to work with parameter and sample sheet schema. The added functionality is:\nnextflow.enable.dsl = 2\n\n/*\n  Standardize input reads from a samplesheet using nf-schema helper.\n\n  Emits: samples_ch → tuple(id, meta_map, reads_list)\n          - id:     sample identifier (string)\n          - meta:   map including `single_end: true|false` plus original fields\n          - reads:  [read1] for SE, [read1, read2] for PE\n*/\n\nparams {\n    sample_table: Path = \"test_data/sample_meta_simple.csv\"\n}\n\ninclude { samplesheetToList } from 'plugin/nf-schema'\n\nworkflow {\n\n    Channel\n        .fromList(samplesheetToList(params.sample_table, \"${projectDir}/assets/schema_input.json\"))\n        .map {\n            meta, read1, read2 -&gt;\n                if (!read2) {\n                    return [ meta.id, meta + [ single_end:true ], [ read1 ] ]\n                } else {\n                    return [ meta.id, meta + [ single_end:false ], [ read1, read2 ] ]\n                }\n        }\n        .set { samples_ch }\n\n    samples_ch.view()\n    // Also log the channel object (structure, not contents)\n    log.info \"Sample channel created: ${samples_ch}\"\n}\nnextflow run . \\\n      -main-script nf_example/test_nf_schema_input.nf \\\n      -c nf_example/test_nf_schema_input.conf",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Validating Input with `nf-schema`</span>"
    ]
  },
  {
    "objectID": "04-advanced_metadata.html#schema-will-check-whether-the-files-exist-or-not",
    "href": "04-advanced_metadata.html#schema-will-check-whether-the-files-exist-or-not",
    "title": "5  Validating Input with nf-schema",
    "section": "5.2 Schema will check whether the files exist or not",
    "text": "5.2 Schema will check whether the files exist or not\n\nnextflow run .  \\\n     -main-script nf_example/test_nf_schema_input.nf \\\n     -c nf_example/test_nf_schema_input.conf \\\n     --sample_table test_data/sample_meta_FileNotExist.csv \n\nWith the schema setting, the files specified in read1 and read2 fields have to exist.\nIf not, the error message below will be shown:\n\n\n\n\n\n\nWarningError\n\n\n\nN E X T F L O W ~ version 25.10.0\nLaunching nf_example/test_nf_schema_input.nf [romantic_gutenberg] DSL2 - revision: eb82818f4d\nERROR ~ Validation of samplesheet failed!\n– Check ‘.nextflow.log’ file for details The following errors have been detected in /mnt/ccrsf-static/Analysis/xies4/github_repos/nextflow_note/test_data/sample_meta_FileNotExist.csv:\n-&gt; Entry 1: Error for field ‘read2’ (/path/to/sample1_fc1_R2.fastq.gz;/path/to/sample1_fc1_R2.fastq.gz): the file or directory ‘/path/to/sample1_fc1_R2.fastq.gz;/path/to/sample1_fc1_R2.fastq.gz’ does not exist (FastQ file for reads 2 cannot contain spaces and must have extension ‘.fq.gz’ or ‘.fastq.gz’) -&gt; Entry 1: Error for field ‘read1’ (/path/to/sample1_fc1_R1.fastq.gz;/path/to/sample1_fc1_R1.fastq.gz): the file or directory ‘/path/to/sample1_fc1_R1.fastq.gz;/path/to/sample1_fc1_R1.fastq.gz’ does not exist (FastQ file for reads 1 must be provided, cannot contain spaces and must have extension ‘.fq.gz’ or ‘.fastq.gz’) -&gt; Entry 2: Error for field ‘read2’ (/path/to/sample2_fc1_R2.fastq.gz;/path/to/sample2_fc1_R2.fastq.gz): the file or directory ‘/path/to/sample2_fc1_R2.fastq.gz;/path/to/sample2_fc1_R2.fastq.gz’ does not exist (FastQ file for reads 2 cannot contain spaces and must have extension ‘.fq.gz’ or ‘.fastq.gz’) -&gt; Entry 2: Error for field ‘read1’ (/path/to/sample2_fc1_R1.fastq.gz;/path/to/sample2_fc1_R1.fastq.gz): the file or directory ‘/path/to/sample2_fc1_R1.fastq.gz;/path/to/sample2_fc1_R1.fastq.gz’ does not exist (FastQ file for reads 1 must be provided, cannot contain spaces and must have extension ‘.fq.gz’ or ‘.fastq.gz’) -&gt; Entry 3: Error for field ‘read2’ (/path/to/sample3_fc1_R2.fastq.gz;/path/to/sample3_fc1_R2.fastq.gz): the file or directory ‘/path/to/sample3_fc1_R2.fastq.gz;/path/to/sample3_fc1_R2.fastq.gz’ does not exist (FastQ file for reads 2 cannot contain spaces and must have extension ‘.fq.gz’ or ‘.fastq.gz’) -&gt; Entry 3: Error for field ‘read1’ (/path/to/sample3_fc1_R1.fastq.gz;/path/to/sample3_fc1_R1.fastq.gz): the file or directory ‘/path/to/sample3_fc1_R1.fastq.gz;/path/to/sample3_fc1_R1.fastq.gz’ does not exist (FastQ file for reads 1 must be provided, cannot contain spaces and must have extension ‘.fq.gz’ or ‘.fastq.gz’)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Validating Input with `nf-schema`</span>"
    ]
  },
  {
    "objectID": "04-advanced_metadata.html#transform-samplesheet-in-csv-to-structured-nextflow-channell",
    "href": "04-advanced_metadata.html#transform-samplesheet-in-csv-to-structured-nextflow-channell",
    "title": "5  Validating Input with nf-schema",
    "section": "5.3 Transform samplesheet in CSV to structured NextFlow channell",
    "text": "5.3 Transform samplesheet in CSV to structured NextFlow channell\nIn the code above, a plain Groovy list is returned.\nThe code below uses explicit tuple() constructor - the canonical DSL 2 form, making it unambiguous and self-documenting.\n\nnextflow.enable.dsl=2\n\n/*\n  Standardize input reads from a samplesheet using nf-schema helper.\n\n  Emits: samples_ch → tuple(id, meta_map, reads_list)\n          - id:     sample identifier (string)\n          - meta:   map including `single_end: true|false` plus original fields\n          - reads:  [read1] for SE, [read1, read2] for PE\n*/\n\nparams.sample_table = file('test_data/sample_meta_simple.csv')\n\n// Helper that turns a samplesheet into a list of [meta, read1, read2?]\ninclude { samplesheetToList } from 'plugin/nf-schema'\n\nworkflow {\n\n  main:\n    Channel\n      .fromList( samplesheetToList(params.sample_table, \"${projectDir}/assets/schema_input.json\") )\n      .map { meta, read1, read2 -&gt;\n        def isSE = !read2\n        tuple(\n          meta.id as String,\n          meta + [ single_end: isSE ],\n          isSE ? [ read1 ] : [ read1, read2 ]\n        )\n      }\n      .set { samples_ch }\n\n    // Optional: inspect the standardized tuples during development\n    samples_ch.view { it }\n\n    // Also log the channel object (structure, not contents)\n    log.info \"Sample channel created: ${samples_ch}\"\n    println \"The Groovy object type of 'samples_ch' is: ${samples_ch.getClass()}\\n\"\n\n    samples_ch.subscribe { item -&gt;\n      println \"Type: ${item.getClass()} | Value: ${item}\"\n    }\n\n}\n\nThis is the standard tuple structure most downstream modules in DSL2 workflows (e.g. nf-core) expect.\n\ntuple(id, meta_map, reads_list)\n\nExplicit tuples make your workflow compatible with DSL 2 modules, where inputs are declared like:\n\ninput: \ntuple val(id), val(meta), path(reads)\n\nThe code below collapses the if/else block into a one-liner ternary operator. The variable isSE stores the boolean.\n\ndef isSE = !read2\ntuple(\n  meta.id as String,\n  meta + [ single_end: isSE ],\n  isSE ? [ read1 ] : [ read1, read2 ]\n)\n\nThis style makes your mapping functional and side-effect-free, which aligns better with how Nextflow channels are transformed. It’s also easier to maintain if you later expand the tuple (e.g., add another metadata field).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Validating Input with `nf-schema`</span>"
    ]
  }
]